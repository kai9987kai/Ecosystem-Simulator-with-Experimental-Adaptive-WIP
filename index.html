<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Ecosystem Simulator – Experimental AI Enhancements</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Load Chart.js (optional, for loss chart) and TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <style>
    :root {
      --primary-bg: #1a1a1a;
      --secondary-bg: #2d2d2d;
      --accent: #4a90e2;
    }
    /* Base styles and theme */
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      background: var(--primary-bg);
      color: #fff;
      height: 100vh;
      overflow: hidden;
      user-select: none;
    }
    body.theme-dark {
      background: #333;
      color: #ddd;
    }
    /* Layout: Sidebar, Dashboard, and Main Canvas */
    .container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      padding: 15px;
      border-radius: 10px;
      z-index: 250;
      max-width: 300px;
    }
    #controls label, #controls h3 {
      display: block;
      margin: 8px 0 4px;
    }
    #controls input, #controls select, #controls button {
      margin: 5px 0;
      width: 100%;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #444;
      background: var(--secondary-bg);
      color: #fff;
    }
    #dashboard {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.85);
      padding: 15px;
      border-radius: 10px;
      z-index: 250;
      max-width: 250px;
    }
    .stat-box {
      margin: 5px 0;
      padding: 5px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 5px;
    }
    #performancePanel {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.85);
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 250;
      max-width: 280px;
    }
    /* Troubleshooting Panel */
    #troubleshooting {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(50,50,50,0.95);
      padding: 15px;
      border-radius: 10px;
      max-height: 300px;
      overflow-y: auto;
      width: 400px;
      display: none;
      z-index: 300;
    }
    #troubleshooting h4 {
      margin-top: 0;
    }
    #toggleTroubleshooting {
      position: fixed;
      bottom: 10px;
      left: 420px;
      z-index: 300;
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
    }
    /* Main Canvas */
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 100;
    }
    /* DALL·E Image Decoration */
    #dalleImage {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 280px;
      height: 200px;
      border: 2px solid var(--accent);
      z-index: 200;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <!-- Controls Panel -->
  <div id="controls">
    <h3>Simulation Controls</h3>
    <label for="agentCount">Agent Count:</label>
    <input type="number" id="agentCount" value="30">
    
    <label for="threatLevel">Threat Level:</label>
    <input type="range" id="threatLevel" min="1" max="5" value="3">
    
    <label for="foodRate">Food Spawn Rate:</label>
    <input type="number" id="foodRate" value="20">
    
    <label for="backendSelect">Backend:</label>
    <select id="backendSelect">
      <option value="webgl">GPU (WebGL)</option>
      <option value="cpu">CPU</option>
    </select>
    
    <!-- Additional User Settings -->
    <label for="agentSpeed">Agent Speed:</label>
    <input type="number" id="agentSpeed" value="3" step="0.1">
    
    <label for="reproduceThreshold">Reproduction Threshold:</label>
    <input type="number" id="reproduceThreshold" value="150">
    
    <label for="metaEvolutionToggle">Meta-Evolution:</label>
    <select id="metaEvolutionToggle">
      <option value="on">Enabled</option>
      <option value="off">Disabled</option>
    </select>
    
    <label for="bgColor">Canvas BG Color:</label>
    <input type="color" id="bgColor" value="#000000">
    
    <button onclick="changeBackend()">Set Backend</button>
    <button onclick="emergencyCleanup()">Emergency Memory Cleanup</button>
    <button onclick="resetSimulation()">Reset Simulation</button>
  </div>

  <!-- Dashboard Panel -->
  <div id="dashboard">
    <div class="stat-box">
      <h4>Population Metrics</h4>
      <p>Agents: <span id="agentCountDisplay">0</span></p>
      <p>Herbivores: <span id="herbivoreCount">0</span></p>
      <p>Carnivores: <span id="carnivoreCount">0</span></p>
      <p>Avg Energy: <span id="avgEnergy">0</span></p>
    </div>
    <div class="stat-box">
      <h4>Environmental Conditions</h4>
      <p>Weather: <span id="weather">Sunny</span></p>
      <p>Temperature: <span id="temperature">25°C</span></p>
      <p>Time of Day: <span id="timeOfDay">12:00</span></p>
    </div>
  </div>

  <!-- Performance Panel -->
  <div id="performancePanel">
    <p id="performanceMetrics">Agents: 0 | Avg Energy: 0</p>
  </div>

  <!-- Canvas -->
  <canvas id="canvas"></canvas>

  <!-- DALL·E-inspired Image Decoration -->
  <img id="dalleImage" alt="DALL-E Generated: Advanced Ecosystem Simulator" src="https://via.placeholder.com/280x200?text=DALL-E+Image">

  <!-- Troubleshooting Panel -->
  <div id="troubleshooting">
    <h4>Troubleshooting Steps</h4>
    <ol>
      <li><strong>Restart System/Application:</strong> Restarting may resolve service issues.</li>
      <li><strong>Check for Bugs:</strong> Run tests and verify functionality.</li>
      <li><strong>Verify Environment:</strong> Ensure weather, temperature, and time settings are correct.</li>
      <li><strong>Inspect Backend:</strong> If GPU is selected but unsupported, switch to CPU.</li>
      <li><strong>Repair Installation:</strong> Confirm all dependencies are intact.</li>
      <li><strong>Avoid Scope Creep:</strong> Ensure no unintended modifications exist.</li>
      <li><strong>Check Data Integrity:</strong> Use backups or checksums to verify file integrity.</li>
      <li><strong>Reset Simulation:</strong> Use the reset option to restore defaults.</li>
    </ol>
  </div>
  <!-- Troubleshooting Toggle Button -->
  <button id="toggleTroubleshooting" onclick="toggleTroubleshooting()">Show Troubleshooting</button>

  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <script>
    // Toggle troubleshooting panel visibility
    function toggleTroubleshooting() {
      const panel = document.getElementById('troubleshooting');
      const btn = document.getElementById('toggleTroubleshooting');
      if (panel.style.display === 'none' || panel.style.display === '') {
        panel.style.display = 'block';
        btn.textContent = 'Hide Troubleshooting';
      } else {
        panel.style.display = 'none';
        btn.textContent = 'Show Troubleshooting';
      }
    }

    // Define and register custom MultiHeadAttentionLayer
    class MultiHeadAttentionLayer extends tf.layers.Layer {
      constructor(config) {
        super(config);
        this.numHeads = config.numHeads;
        this.keyDim = config.keyDim;
      }
      build(inputShape) {
        const dModel = inputShape[2];
        this.wq = this.addWeight('wq', [dModel, this.numHeads * this.keyDim], 'float32', tf.initializers.glorotUniform());
        this.wk = this.addWeight('wk', [dModel, this.numHeads * this.keyDim], 'float32', tf.initializers.glorotUniform());
        this.wv = this.addWeight('wv', [dModel, this.numHeads * this.keyDim], 'float32', tf.initializers.glorotUniform());
        this.built = true;
      }
      call(inputs, kwargs) {
        const x = inputs; // [batch, seq, dModel]
        const batchSize = x.shape[0];
        const seqLen = x.shape[1];
        let q = tf.dot(x, this.wq.read());
        let k = tf.dot(x, this.wk.read());
        let v = tf.dot(x, this.wv.read());
        q = tf.reshape(q, [batchSize, seqLen, this.numHeads, this.keyDim]);
        k = tf.reshape(k, [batchSize, seqLen, this.numHeads, this.keyDim]);
        v = tf.reshape(v, [batchSize, seqLen, this.numHeads, this.keyDim]);
        q = tf.transpose(q, [0, 2, 1, 3]);
        k = tf.transpose(k, [0, 2, 1, 3]);
        v = tf.transpose(v, [0, 2, 1, 3]);
        const scale = Math.sqrt(this.keyDim);
        let scores = tf.matMul(q, k, false, true);
        scores = tf.div(scores, scale);
        const weights = tf.softmax(scores, -1);
        let attnOutput = tf.matMul(weights, v);
        attnOutput = tf.transpose(attnOutput, [0, 2, 1, 3]);
        return tf.reshape(attnOutput, [batchSize, seqLen, this.numHeads * this.keyDim]);
      }
      computeOutputShape(inputShape) {
        return [inputShape[0], inputShape[1], this.numHeads * this.keyDim];
      }
      getClassName() {
        return 'MultiHeadAttentionLayer';
      }
    }
    tf.serialization.registerClass(MultiHeadAttentionLayer);

    // Set backend to WebGL with fallback to CPU
    tf.setBackend('webgl').catch(() => {
      tf.setBackend('cpu');
      console.log("WebGL not supported; using CPU backend.");
    }).then(() => console.log(`Backend set to ${tf.getBackend().toUpperCase()}`));

    // Resize canvas and fill with user-specified background color
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();

    // Global simulation parameters
    let agents = [];
    let foods = [];
    let threats = [];
    let timeOfDay = 12; // Noon
    let weather = 'Sunny';
    let temperature = 25;
    const agentEnergyDecay = 0.05;
    const foodReward = 20;
    const threatPenalty = 30;
    let reproduceThreshold = parseFloat(document.getElementById("reproduceThreshold").value);
    const energyThresholdForReset = 30; // Meta-evolution threshold

    // Experimental: Meta-Evolution: reinitialize 20% of agent brains if average energy is low.
    function metaEvolution() {
      if (agents.length === 0) return;
      const totalEnergy = agents.reduce((sum, a) => sum + a.energy, 0);
      const avgEnergy = totalEnergy / agents.length;
      if (avgEnergy < energyThresholdForReset && document.getElementById("metaEvolutionToggle").value === "on") {
        console.warn(`Average energy (${avgEnergy.toFixed(1)}) is low. Reinitializing 20% of agents (meta-evolution).`);
        const countToReset = Math.floor(agents.length * 0.2);
        for (let i = 0; i < countToReset; i++) {
          const idx = Math.floor(Math.random() * agents.length);
          try {
            agents[idx].brain.dispose();
            agents[idx].brain = agents[idx].createBrain();
          } catch (e) {
            console.error("Meta-evolution reinitialization failed for agent", idx, e);
          }
        }
      }
    }

    // Helper: ensure tensor has a batch dimension
    function ensureBatchDim(x) {
      if (x.shape.length === 2) {
        return { tensor: tf.expandDims(x, 0), squeezed: true };
      } else {
        return { tensor: x, squeezed: false };
      }
    }

    // Transformer block: project input to dimension 10
    function transformerBlock(x) {
      const { tensor: xBatch, squeezed } = ensureBatchDim(x);
      const xProjected = tf.layers.dense({ units: 10 }).apply(xBatch);
      const mha = new MultiHeadAttentionLayer({ numHeads: 2, keyDim: 5 });
      const attnOutput = mha.apply(xProjected);
      const add1 = tf.layers.add().apply([xProjected, attnOutput]);
      const norm1 = tf.layers.layerNormalization().apply(add1);
      const ff1 = tf.layers.dense({ units: 32, activation: 'relu' }).apply(norm1);
      const ffOut = tf.layers.dense({ units: 10 }).apply(ff1);
      const add2 = tf.layers.add().apply([norm1, ffOut]);
      const norm2 = tf.layers.layerNormalization().apply(add2);
      let output = tf.layers.dropout({ rate: 0.1 }).apply(norm2);
      if (squeezed) {
        output = tf.squeeze(output, [0]);
      }
      return output;
    }

    // Base Entity class
    class Entity {
      constructor(x, y, size, color) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.color = color;
        this.isAlive = true;
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Agent class with transformer-based brain (fallback to dense) and memory-safe handling
    class Agent extends Entity {
      constructor(x, y) {
        super(x, y, 8, '#00ff00');
        this.energy = 100;
        this.speed = parseFloat(document.getElementById("agentSpeed").value);
        try {
          this.brain = this.createBrain();
        } catch (e) {
          console.error("Transformer network creation failed; falling back to dense network.", e);
          this.brain = this.createDenseBrain();
        }
      }
      createBrain() {
        const input = tf.input({ shape: [5] });
        let xSeq = tf.layers.repeatVector({ n: 4 }).apply(input);
        xSeq = transformerBlock(xSeq);
        xSeq = transformerBlock(xSeq);
        xSeq = transformerBlock(xSeq);
        const flat = tf.layers.flatten().apply(xSeq);
        const denseBoost = tf.layers.dense({ units: 64, activation: 'relu' }).apply(flat);
        const output = tf.layers.dense({ units: 2, activation: 'tanh' }).apply(denseBoost);
        const model = tf.model({ inputs: input, outputs: output });
        model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });
        return model;
      }
      createDenseBrain() {
        const input = tf.input({ shape: [5] });
        let x = tf.layers.dense({ units: 32, activation: 'relu' }).apply(input);
        x = tf.layers.dense({ units: 32, activation: 'relu' }).apply(x);
        const output = tf.layers.dense({ units: 2, activation: 'tanh' }).apply(x);
        const model = tf.model({ inputs: input, outputs: output });
        model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });
        return model;
      }
      getState() {
        const nearestFood = this.findNearest(foods);
        const nearestThreat = this.findNearest(threats);
        const foodDist = nearestFood ? nearestFood.distance / canvas.width : 1;
        const threatDist = nearestThreat ? nearestThreat.distance / canvas.height : 1;
        const timeFactor = Math.sin(timeOfDay * Math.PI / 12);
        const tempNorm = temperature / 50;
        const energyNorm = this.energy / 100;
        return [foodDist, threatDist, timeFactor, tempNorm, energyNorm];
      }
      findNearest(entities) {
        let nearest = null;
        let minDist = Infinity;
        for (const entity of entities) {
          const dx = entity.x - this.x;
          const dy = entity.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < minDist) {
            minDist = dist;
            nearest = { entity, distance: dist };
          }
        }
        return nearest;
      }
      async act() {
        const state = this.getState();
        const action = tf.tidy(() => {
          const tensor = tf.tensor2d([state]);
          const prediction = this.brain.predict(tensor);
          return prediction.dataSync();
        });
        this.move(action[0], action[1]);
      }
      move(dx, dy) {
        this.x += dx * this.speed;
        this.y += dy * this.speed;
        this.keepInBounds();
      }
      keepInBounds() {
        this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
        this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
      }
      updateEnergy() {
        for (let i = foods.length - 1; i >= 0; i--) {
          const food = foods[i];
          const dist = Math.hypot(food.x - this.x, food.y - this.y);
          if (dist < 20) {
            this.energy += foodReward;
            foods.splice(i, 1);
          }
        }
        for (const threat of threats) {
          const dist = Math.hypot(threat.x - this.x, threat.y - this.y);
          if (dist < 40) {
            this.energy -= threatPenalty;
          }
        }
        this.energy -= agentEnergyDecay;
        if (this.energy > reproduceThreshold) {
          this.reproduce();
          this.energy /= 2;
        }
        if (this.energy <= 0) {
          this.isAlive = false;
        }
      }
      reproduce() {
        const newX = this.x + randBetween(-20, 20);
        const newY = this.y + randBetween(-20, 20);
        const child = new Agent(newX, newY);
        child.energy = this.energy / 2;
        agents.push(child);
      }
    }

    // Threat class
    class Threat extends Entity {
      constructor(x, y) {
        super(x, y, 12, '#ff0000');
        this.speed = 4;
      }
      move() {
        if (agents.length > 0) {
          const target = agents[Math.floor(Math.random() * agents.length)];
          const dx = target.x - this.x;
          const dy = target.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 0) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
          }
        }
      }
    }

    // Food class
    class Food extends Entity {
      constructor(x, y) {
        super(x, y, 6, '#ffff00');
      }
    }

    // Process agents in asynchronous batches (simulate multiprocessing)
    async function processAgentsInBatches(batchSize = 10) {
      for (let i = 0; i < agents.length; i += batchSize) {
        const batch = agents.slice(i, i + batchSize);
        await Promise.all(batch.map(async agent => {
          if (!agent.isAlive) return;
          await agent.act();
          agent.updateEnergy();
        }));
      }
    }

    // Initialize simulation: create agents, food, and threats
    function initializeSimulation() {
      const agentCountInput = parseInt(document.getElementById('agentCount').value);
      const foodCount = parseInt(document.getElementById('foodRate').value);
      const newAgentSpeed = parseFloat(document.getElementById("agentSpeed").value);
      reproduceThreshold = parseFloat(document.getElementById("reproduceThreshold").value);
      agents = Array.from({ length: agentCountInput }, () => {
        const agent = new Agent(randBetween(0, canvas.width), randBetween(0, canvas.height));
        agent.speed = newAgentSpeed;
        return agent;
      });
      threats = Array.from({ length: 5 }, () => new Threat(randBetween(0, canvas.width), randBetween(0, canvas.height)));
      foods = Array.from({ length: foodCount }, () => new Food(randBetween(0, canvas.width), randBetween(0, canvas.height)));
    }

    // Main simulation update loop
    async function updateSimulation() {
      // Fill canvas with user-specified background color
      const bgColor = document.getElementById("bgColor").value;
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      await processAgentsInBatches(10);
      agents.forEach(agent => { if (agent.isAlive) agent.draw(); });
      threats.forEach(threat => { threat.move(); threat.draw(); });
      foods.forEach(food => food.draw());
      
      document.getElementById('agentCountDisplay').textContent = agents.length;
      const avgEnergy = agents.length > 0 ? (agents.reduce((sum, a) => sum + a.energy, 0) / agents.length).toFixed(1) : 0;
      document.getElementById('avgEnergy').textContent = avgEnergy;
      
      // Experimental: meta-evolution if average energy is low
      metaEvolution();
      
      // Update performance panel
      updatePerformancePanel();
      
      requestAnimationFrame(updateSimulation);
    }

    // Update performance panel with metrics
    function updatePerformancePanel() {
      const panel = document.getElementById("performancePanel");
      const avgEnergy = agents.length > 0 ? (agents.reduce((sum, a) => sum + a.energy, 0) / agents.length).toFixed(1) : 0;
      panel.textContent = `Agents: ${agents.length} | Avg Energy: ${avgEnergy}`;
    }

    // Change TensorFlow.js backend based on user selection
    async function changeBackend() {
      const select = document.getElementById('backendSelect');
      const backend = select.value;
      await tf.setBackend(backend);
      await tf.ready();
      console.log(`Switched to ${backend.toUpperCase()} backend.`);
    }

    // Emergency memory cleanup: reset simulation if JS heap usage exceeds 200 MB
    function emergencyCleanup() {
      if (performance && performance.memory) {
        const { usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
        console.log(`Memory usage: ${(usedJSHeapSize/1048576).toFixed(2)} MB / ${(jsHeapSizeLimit/1048576).toFixed(2)} MB`);
        if (usedJSHeapSize > 200 * 1048576) {
          console.warn("Memory threshold exceeded. Resetting simulation.");
          resetSimulation();
        } else {
          console.log("Memory usage is within safe limits.");
        }
      } else {
        console.log("performance.memory not supported in this browser.");
      }
    }

    // Improved simulation reset with full memory cleanup
    function resetSimulation() {
      agents.forEach(agent => {
        if (agent.brain) {
          agent.brain.dispose();
        }
      });
      agents = [];
      threats = [];
      foods = [];
      initializeSimulation();
      timeOfDay = 12;
      weather = 'Sunny';
      temperature = 25;
      console.clear();
      console.log("Simulation reset with full memory cleanup.");
    }

    // Resize canvas on window resize
    window.addEventListener('resize', resizeCanvas);

    // Log average energy every 10 seconds
    setInterval(() => {
      const avgEnergy = agents.length > 0 ? (agents.reduce((sum, a) => sum + a.energy, 0) / agents.length).toFixed(1) : 0;
      console.log(`Interpreter Output: Agents: ${agents.length}, Avg Energy: ${avgEnergy}`);
    }, 10000);

    // Enhanced weight perturbation with tf.tidy (adaptive update)
    setInterval(() => {
      agents.forEach(agent => {
        agent.brain.layers.forEach(layer => {
          tf.tidy(() => {
            const weights = layer.getWeights();
            const newWeights = weights.map(w => {
              const vals = w.dataSync().slice();
              return tf.tensor(vals.map(v => v + randBetween(-0.01, 0.01)), w.shape);
            });
            layer.setWeights(newWeights);
          });
        });
      });
      console.log("Safe adaptive update applied to agent brains.");
    }, 15000);

    // Experimental dynamic learning rate adaptation (rudimentary)
    setInterval(() => {
      agents.forEach(agent => {
        try {
          const oldLR = agent.brain.optimizer.learningRate;
          const factor = 1 + randBetween(-0.05, 0.05);
          if (typeof oldLR === 'number') {
            agent.brain.optimizer.learningRate = oldLR * factor;
            console.log(`Adjusted learning rate to ${agent.brain.optimizer.learningRate.toFixed(4)}`);
          }
        } catch (e) {
          console.warn("Dynamic learning rate adjustment failed:", e);
        }
      });
    }, 30000);

    // Start simulation
    initializeSimulation();
    updateSimulation();
  </script>
</body>
</html>
